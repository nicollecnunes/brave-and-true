; This is the Calva evaluation results output window.
; TIPS: The keyboard shortcut `ctrl+alt+o o` shows and focuses this window
;   when connected to a REPL session.
; Please see https://calva.io/output/ for more info.
; Happy coding! ♥️

; Jacking in...
; Connecting using "Leiningen" project type.
; You can make Calva auto-select this.
;   - See https://calva.io/connect-sequences/
; 
; Starting Jack-in Terminal: pushd /Users/nicolle.nunes/dev/nu/brave-and-true/Exercism/clojure/accumulate ; lein update-in :dependencies conj '[nrepl,"1.0.0"]' -- update-in :plugins conj '[cider/cider-nrepl,"0.28.5"]' -- update-in '[:repl-options,:nrepl-middleware]' conj '["cider.nrepl/cider-middleware"]' -- repl :headless ; popd
; Using host:port 127.0.0.1:50843 ...
; Hooking up nREPL sessions ...
; Connected session: clj
; TIPS:
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - Clojure lines in stack traces are peekable and clickable.
clj꞉user꞉>  ; Use `alt+enter` to evaluate
; Jack-in done.
clj꞉user꞉> 
(defn accumulate
  [fn list]
  (cond
    (empty? list) nil
    :else (conj (fn (first list)) (accumulate fn (rest list)))))
#'user/accumulate
clj꞉user꞉> (defn- square [n] (* n n))
#'user/square
clj꞉user꞉> 
(accumulate square [1 2 3])
; Execution error (ClassCastException) at user/accumulate (form-init546950757922799751.clj:30).
; class java.lang.Long cannot be cast to class clojure.lang.IPersistentCollection (java.lang.Long is in module java.base of loader 'bootstrap'; clojure.lang.IPersistentCollection is in unnamed module of loader 'app')
clj꞉user꞉> 
first [1 2 3]
[1 2 3]
clj꞉accumulate꞉> 
(first [1 2 3])
1
clj꞉accumulate꞉> 
(square (first [1 2 3]))
; Syntax error compiling at (output.calva-repl:45:1).
; Unable to resolve symbol: square in this context
clj꞉accumulate꞉> defn- square [n] (* n n)
; Syntax error compiling at (output.calva-repl:48:35).
; Unable to resolve symbol: n in this context
clj꞉accumulate꞉> (defn- square [n] (* n n))
#'accumulate/square
clj꞉accumulate꞉> (square (first [1 2 3]))
1
clj꞉accumulate꞉> (square (rest [1 2]))
; Execution error (ClassCastException) at accumulate/square (form-init546950757922799751.clj:51).
; class clojure.lang.PersistentVector$ChunkedSeq cannot be cast to class java.lang.Number (clojure.lang.PersistentVector$ChunkedSeq is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap')
clj꞉accumulate꞉> 
(defn accumulate
  [fn list]
  (print list)
  (cond
    (empty? list) (print nil)
    :else (print (conj (fn (first list)) (accumulate fn (rest list))))))
#'accumulate/accumulate
clj꞉accumulate꞉> (defn- square [n] (* n n))
#'accumulate/square
clj꞉accumulate꞉> (accumulate square [1 2 3])
[1 2 3](2 3)(3)()nil; Execution error (ClassCastException) at accumulate/accumulate (form-init546950757922799751.clj:64).
; class java.lang.Long cannot be cast to class clojure.lang.IPersistentCollection (java.lang.Long is in module java.base of loader 'bootstrap'; clojure.lang.IPersistentCollection is in unnamed module of loader 'app')
clj꞉accumulate꞉> 
(defn accumulate
  [fn list]
  (print (str "lista: " list))
  (cond
    (empty? list) (print nil)
    :else (print (conj (fn (first list)) (accumulate fn (rest list))))))
#'accumulate/accumulate
clj꞉accumulate꞉> 
(accumulate square [1 2 3])
lista: [1 2 3]lista: (2 3)lista: (3)lista: ()nil; Execution error (ClassCastException) at accumulate/accumulate (form-init546950757922799751.clj:77).
; class java.lang.Long cannot be cast to class clojure.lang.IPersistentCollection (java.lang.Long is in module java.base of loader 'bootstrap'; clojure.lang.IPersistentCollection is in unnamed module of loader 'app')
clj꞉accumulate꞉> 
(defn accumulate
  [fn list]
  (cond
    (empty? list) nil
    :else ((print (str "first: " (first list)))
           (print (str "first fn: " (fn (first list))))
           (print (str "rest: " (rest list)))

           (conj (fn (first list)) (accumulate fn (rest list))))))
#'accumulate/accumulate
clj꞉accumulate꞉> 
(accumulate square [1 2 3])
first: 1first fn: 1rest: (2 3)first: 2first fn: 4rest: (3)first: 3first fn: 9rest: (); Execution error (ClassCastException) at (REPL:1).
; null
(defn accumulate
  [fn list]
  (cond
    (empty? list) nil
    :else ((println (str "first: " (first list)))
           (println (str "first fn: " (fn (first list))))
           (println (str "rest: " (rest list)))

           (conj (fn (first list)) (accumulate fn (rest list))))))
#'accumulate/accumulate
clj꞉accumulate꞉> (accumulate square [1 2 3])
first: 1
first fn: 1
rest: (2 3)
first: 2
first fn: 4
rest: (3)
first: 3
first fn: 9
rest: ()
; Execution error (ClassCastException) at (REPL:1).
; null
(rest (1))
; Execution error (ClassCastException) at accumulate/eval9756 (form-init546950757922799751.clj:120).
; class java.lang.Long cannot be cast to class clojure.lang.IFn (java.lang.Long is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'app')
clj꞉accumulate꞉> 
(rest [1])
()
clj꞉accumulate꞉> 
(defn accumulate
  [fn list]
  (cond
    (empty? (rest list)) (conj (fn (first list)))
    :else (conj (fn (first list)) (accumulate fn (rest list)))))
#'accumulate/accumulate
clj꞉accumulate꞉> (accumulate square [1 2 3])
; Execution error (ClassCastException) at (REPL:1).
; null
(defn accumulate
  [function list]
  (cond
    (empty? (rest list)) (conj (function (first list)))
    :else (conj (function (first list)) (accumulate function (rest list)))))
#'accumulate/accumulate
clj꞉accumulate꞉> 
(accumulate square [1 2 3])
; Execution error (ClassCastException) at (REPL:1).
; null
(defn accumulate
  [function list]
  (cond
    (empty? (rest list)) ((println "returning the first w fn") (conj (function (first list))))
    :else (conj (function (first list)) (accumulate function (rest list)))))
#'accumulate/accumulate
clj꞉accumulate꞉> 
(accumulate square [1 2 3])
returning the first w fn
; Execution error (NullPointerException) at accumulate/accumulate (form-init546950757922799751.clj:149).
; Cannot invoke "clojure.lang.IFn.invoke(Object)" because the return value of "clojure.lang.IFn.invoke(Object)" is null
clj꞉accumulate꞉> 
(defn accumulate
  [fn list]
  (let [primeiro (first list)
        outros (rest list)]
    (println (str "iniciando cm a list: " list))
    (println (str "outros: " outros))
    (println (str "primeiro: " primeiro))))
#'accumulate/accumulate
clj꞉accumulate꞉> 
(accumulate square [1 2 3])
iniciando cm a list: [1 2 3]
outros: (2 3)
primeiro: 1
nil
clj꞉accumulate꞉> 
(rest [1 2])
(2)
clj꞉accumulate꞉> 
(rest [1
])
()
clj꞉accumulate꞉> 
(defn accumulate
  [fn list]
  (let [primeiro (first list)
        outros (rest list)]
    (cond
      (empty? outros) (println (str "outros vazio: " outros))
      :else (println (str "outros :" outros "........ first ln: " (fn primeiro))))))
#'accumulate/accumulate
clj꞉accumulate꞉> 
(accumulate square [1 2 3])
outros :(2 3)........ first ln: 1
nil
clj꞉accumulate꞉> 
(accumulate square [1])
outros vazio: ()
nil
clj꞉accumulate꞉> 
(conj 1)
1
clj꞉accumulate꞉> 
(conj 1 (
))
; Execution error (ClassCastException) at (REPL:1).
; null
(defn accumulate
  [fn list]
  (let [primeiro (first list)
        outros (rest list)]
    (cond
      (empty? list) (empty list)
      (empty? outros) (println (conj (fn primeiro) outros))
      :else (println (str "outros :" outros "........ first ln: " (fn primeiro))))))
#'accumulate/accumulate
clj꞉accumulate꞉> 
(accumulate square [1])
; Execution error (ClassCastException) at (REPL:1).
; null
; Execution error (ClassCastException) at (REPL:1).
; null
; Execution error (ClassCastException) at (REPL:1).
; null
(accumulate square [1])
; Execution error (ClassCastException) at (REPL:1).
; null
(accumulate square [1 2 3])
outros :(2 3)........ first ln: 1
nil
clj꞉accumulate꞉> 
(empty [
])
[]
clj꞉accumulate꞉> 
(conj 1 (empty ()))
; Execution error (ClassCastException) at (REPL:1).
(empty (list)); null
()
clj꞉accumulate꞉> 
(defn accumulate
  [fn lista]
  (let [primeiro (first lista)
        outros (rest lista)]
    (cond
      (empty? lista) (empty (list))
      (empty? outros) (println (conj (fn primeiro) outros))
      :else (println (str "outros :" outros "........ first ln: " (fn primeiro))))))
#'accumulate/accumulate
clj꞉accumulate꞉> 
(accumulate square [1 2 3])
outros :(2 3)........ first ln: 1
nil
clj꞉accumulate꞉> 
(accumulate square [1])
; Execution error (ClassCastException) at (REPL:1).
; null
(first [1])
1
clj꞉accumulate꞉> 
(conj 1 (2 3))
; Execution error (ClassCastException) at accumulate/eval9809 (form-init546950757922799751.clj:257).
; class java.lang.Long cannot be cast to class clojure.lang.IFn (java.lang.Long is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'app')
clj꞉accumulate꞉> 
(defn accumulate
  [fn lista]
  (let [primeiro (first lista)
        outros (rest lista)]
    (cond
      (empty? lista) (empty (list))
      (empty? outros) (println (conj '(empty (list)) (fn primeiro)))
      :else (println (str "outros :" outros "........ first ln: " (fn primeiro))))))
#'accumulate/accumulate
clj꞉accumulate꞉> 
(accumulate square [1 2 3])
outros :(2 3)........ first ln: 1
nil
clj꞉accumulate꞉> 
(accumulate square [1])
(1 empty (list))
nil
clj꞉accumulate꞉> 
(list 1)
(1)
clj꞉accumulate꞉> 
(defn accumulate
  [fn lista]
  (let [primeiro (first lista)
        outros (rest lista)]
    (cond
      (empty? lista) (empty (list))
      (empty? outros) (println (list (fn primeiro)))
      :else (println (str "outros :" outros "........ first ln: " (fn primeiro))))))
#'accumulate/accumulate
clj꞉accumulate꞉> (accumulate square [1])
(1)
nil
clj꞉accumulate꞉> 
(list (1) (2 3))
; Execution error (ClassCastException) at accumulate/eval9821 (form-init546950757922799751.clj:295).
; class java.lang.Long cannot be cast to class clojure.lang.IFn (java.lang.Long is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'app')
clj꞉accumulate꞉> 
(conj (1) (2 3))
; Execution error (ClassCastException) at accumulate/eval9823 (form-init546950757922799751.clj:299).
; class java.lang.Long cannot be cast to class clojure.lang.IFn (java.lang.Long is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'app')
clj꞉accumulate꞉> 
(vector)
[]
clj꞉accumulate-test꞉> (conj 1 [2 3])
; Execution error (ClassCastException) at (REPL:1).
; null()
; Execution error (ClassCastException) at (REPL:1).
; null
]; Execution error (ClassCastException) at (REPL:1).
; null

(conj (vector 1) [2 3])
[1 [2 3]]
clj꞉accumulate-test꞉> 
(conj [2 3] 1)
[2 3 1]
clj꞉accumulate-test꞉> 
(conj '[2 3] 1)
[2 3 1]
clj꞉accumulate-test꞉> 
(conj 1 [2 3])
; Execution error (ClassCastException) at (REPL:1).
; null
(into 1 [2 3])
; Execution error (ClassCastException) at (REPL:1).
; null
(concat 1 [2 3])
; Error printing return value (IllegalArgumentException) at clojure.lang.RT/seqFrom (RT.java:553).
; Don't know how to create ISeq from: java.lang.Long
clj꞉accumulate-test꞉> 
(into (vector 1) [1 2 3])
[1 1 2 3]
clj꞉accumulate-test꞉> 
(defn accumulate
  [fn lista]
  (let [primeiro (first lista)
        outros (rest lista)]
    (cond
      (empty? lista) (vector)
      (empty? outros) (println (vector (fn primeiro)))
      :else (into (vector (fn primeiro)) (accumulate fn outros)))))
#'accumulate-test/accumulate
clj꞉accumulate-test꞉> 
(accumulate square [1 2 3])
; Syntax error compiling at (output.calva-repl:345:1).
; Unable to resolve symbol: square in this context
clj꞉accumulate-test꞉> 
(defn- square [n] (* n n))
#'accumulate-test/square
clj꞉accumulate-test꞉> 
(accumulate square [1 2 3])
[9]
[1 4]
clj꞉accumulate-test꞉> 
(defn accumulate
  [fn lista]
  (let [primeiro (first lista)
        outros (rest lista)]
    (cond
      (empty? lista) (vector)
      (empty? outros) (vector (fn primeiro))
      :else (into (vector (fn primeiro)) (accumulate fn outros)))))
#'accumulate-test/accumulate
clj꞉accumulate-test꞉> (accumulate square [1 2 3])
[1 4 9]
clj꞉accumulate-test꞉> 
